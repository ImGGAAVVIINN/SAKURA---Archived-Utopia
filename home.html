<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Home Page</title>
  <link rel="stylesheet" href="home.css" />
        <link rel="stylesheet" href="https://unpkg.com/7.css/dist/7.scoped.css" />
    <!-- GSAP Core -->
        <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>
    <!-- GSAP Plugins -->
        <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/ScrollTrigger.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/SplitText.min.js"></script>
    <!-- Lenis -->
    <script src="https://cdn.jsdelivr.net/npm/@studio-freight/lenis@1.0.35/dist/lenis.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.js"></script>
        <script>
            // Set manual scroll restoration early so the browser doesn't restore scroll on reload
            if ('scrollRestoration' in history) history.scrollRestoration = 'manual'
            // Quick defensive scroll to top as early as possible
            try { window.scrollTo(0,0) } catch (e) {}
            window.addEventListener('pageshow', (e) => { if (e.persisted) try { window.scrollTo(0,0) } catch (e) {} })
        </script>
</head>
<body class="has-scrollbar">
        <!-- White fade-in overlay -->
        <div id="page-fade-overlay"></div>
        
                <!-- Pre-Welcome Page (merged index content: HTML + CSS + JS) -->
                <div id="pre-welcome-page" style="position: fixed; inset: 0; z-index: 10010; display: none; align-items: center; justify-content: center; background: linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.8)); color: white;">
                    <div style="width:100%; max-width:1100px; margin:auto;">
                        <!-- Embedded styles from style.css (scoped inside page but global rules apply) -->
                        <style>
/* BEGIN embedded style.css (partial/essential) */
@import url('https://unpkg.com/normalize.css') layer(normalize);

@font-face {
    font-family: 'Frutiger';
    src: url('fonts/frutiger/Frutiger.ttf') format('truetype');
}

/* Important styles copied from style.css to render the pre-welcome "index" page */
body, #pre-welcome-page { font-family: 'Frutiger', sans-serif; }
.lights-background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #0b0b0b;
    background-color: #ffffff;
    z-index: -1;
    overflow: hidden;
}
.light {
    position: absolute;
    border-radius: 50%;
    filter: blur(80px);
    opacity: 0;
    animation: fadeInOut 4s ease-in-out infinite;
}
.light.blue { background: radial-gradient(circle, rgba(0, 120, 212, 0.7) 0%, transparent 70%); }
.light.green { background: radial-gradient(circle, rgba(16, 137, 62, 0.7) 0%, transparent 70%); }
.light.pink { background: radial-gradient(circle, rgba(232, 17, 127, 0.7) 0%, transparent 70%); }
.arrow { font-family: 'Frutiger', sans-serif; font-size: 20px; color:#fff; }

@keyframes fadeInOut { 0%,100%{opacity:0;transform:scale(0.8);}50%{opacity:1;transform:scale(1);} }

.liquid-toggle { --height:30; --width:100; height: calc(var(--height)*1px); width: calc(var(--width)*1px); border-radius:3px; border:1px solid #8e8f8f; padding:0; cursor:pointer; position:relative; overflow:visible; background:#ddd; }
.liquid-toggle .indicator { position:absolute; top:50%; left:50%; translate:-50% -50%; height:100%; width:100%; background:#00d82c; border-radius:3px; }
.liquid-toggle.pre-pop { opacity:0; transform: translate(-50%, -50%) translate3d(0,24px,0) scale(.6); filter:blur(6px); pointer-events:none; }
/* remove pre-welcome override: toggle stays hidden until we explicitly show it via JS */
/* #pre-welcome-page .liquid-toggle.pre-pop { opacity: 1 !important; transform: none !important; filter: none !important; pointer-events: auto !important; } */
.liquid-toggle.pop-in { animation-name: jello-pop; animation-duration: 900ms; animation-fill-mode:both; }
@keyframes jello-pop { 0%{transform:translate(-50%, -50%) translate3d(0,24px,0) scale(.6);opacity:0;filter:blur(6px);} 40%{transform:translate(-50%, -50%) translate3d(0,-8px,0) scale(1.18);opacity:1;} 100%{transform:translate(-50%, -50%);opacity:1;filter:none;} }

.white-flash-overlay { position: fixed; inset: 0; background: #fff; z-index: 99999; pointer-events: none; clip-path: circle(0px at 0px 0px); transition: clip-path 520ms cubic-bezier(.22,.9,.33,1), opacity 220ms linear; opacity:1; }

.arrow--main { position: absolute; top: 1.5rem; left: 1.5rem; color:#fff; opacity:0.9; }

/* END embedded style.css */


@import url('https://unpkg.com/normalize.css') layer(normalize);

@font-face {
  font-family: 'Frutiger';
  src: url('fonts/frutiger/Frutiger.ttf') format('truetype');
}

@layer normalize, base, demo, toggle, transitions, debug;

@layer debug {
  .arrow {
    font-family: 'Gloria Hallelujah', cursive;
    font-size: .875rem;
    position: absolute;
    opacity: .6;

    span {
      white-space: nowrap;
      display: inline-block;
    }

    &.arrow--main {
      right: 120%;
      rotate: -30deg;
      transition: opacity .26s ease-out;
      svg {
        rotate: 10deg;
        width: 24px;
        top: 150%;
        left: 50%;
        position: absolute;
        scale: -1 1;
      }
      /* use Frutiger for the main "tap and drag" callout */
    }
  }
  [data-debug=true] {
    main {
      transform: rotateX(-24deg) rotateY(24deg);
      transition: transform 0.32s ease-out;
    }
    :is(.debug, .knockout--debug) {
      opacity: 1;
      transition-property: transform, opacity;
      transition-duration: 0.32s, 0.32s;
      transition-delay: 0.4s, 0.4s;
      transition-timing-function: ease-out, ease-in;
    }
    .debug--knockout {
      transform: translate3d(0, 0, -200px);
    }
    .debug--indicator {
      transform: translate3d(0, 0, 200px);
    }
    .debug .arrow {
      opacity: .6;
      transition: opacity 0.1s 0.8s ease-out;
    }
  }
  .debug {
    transform-style: preserve-3d;
    outline: 4px var(--checked) dashed;
    outline-offset: 4px;
    height: 100%;
    width: 100%;
    opacity: 0;
    border-radius: inherit;
    pointer-events: none;
    position: absolute;
    inset: 0;
    
    .arrow {
      transform-style: preserve-3d;
      position: absolute;
      left: calc(100% + 2rem);
      top: 50%;
      translate: 0 -50%;
      transform: rotateY(-24deg) rotateX(24deg) translate3d(0, 0, 100px);
      z-index: 20;
      opacity: 0;
    }
  }
  .indicator__liquid--debug {
    pointer-events: none;
    
    .wrapper {
      clip-path: unset;
    }
    .liquids {
      overflow: visible;
    }
  }

  :is(.debug) {
    transition-property: transform, opacity;
    transition-duration: 0.32s, 0.32s;
    transition-delay: 0.2s, 0.2s;
    transition-timing-function: ease-in, ease-out;
  }
  
  main {
    position: relative;
    transition: transform 0.32s 0.4s ease-out;
  }

  main,
  .liquid-toggle {
    transform-style: preserve-3d;
  }
}

@layer transitions {
  :root {
    --transition: 0.2s;
    --ease: ease-out;
  }
  [data-pressed=true] .liquid__track {
    min-height: 15px;
  }
  [data-bounce='true']:has(:is(button:active, [data-pressed="true"])) {
    --transition: 0.6s;
    --ease: linear(
      0 0%,
      0.6091 3.69%,
      1.0259 7.24%,
      1.1733 9.05%,
      1.283 10.92%,
      1.3562 12.87%,
      1.3948 14.95%,
      1.4014 16.03%,
      1.3999 17.16%,
      1.3731 19.64%,
      1.3202 22.27%,
      1.1394 29.39%,
      1.0582 33.17%,
      0.9943 37.45%,
      0.9734 39.64%,
      0.9593 41.92%,
      0.9505 45.08%,
      0.9517 48.7%,
      0.9924 63.02%,
      1.0046 71.2%,
      1.0061 78.24%,
      1 100%
    );
  }
  .indicator--masked .mask {
    translate: calc(
        (var(--complete) / 100) * (100cqi - 60cqi - (0 * var(--border)))
      ) -50%;
    transition-property: height, width, margin, scale;
    transition-duration: var(--transition);
    transition-timing-function: var(--ease);
    will-change: height, width, margin;
  }
  .wrapper {
    clip-path: inset(0 0 0 0 round 100px);
    filter: blur(6px);
    transition: filter var(--transition) var(--ease);
  }
  [aria-pressed='true']:not([data-active='true']) .liquid__track {
    left: calc(var(--border) * 6);
  }
  .liquid__track {
    left: 0;
    transition-property: height, width, filter, left;
    transition-duration: var(--transition);
    transition-timing-function: var(--ease);
    translate: calc(
        (var(--complete) / 100) * (100cqi - 100% - (6 * var(--border)))
      ) -50%;
  }
  [data-mapped=false] .liquid__track {
    transition-property: height, width, filter, left, background;
    transition-duration: var(--transition), var(--transition), var(--transition), var(--transition), calc(var(--transition) * 0.5);
    transition-timing-function: var(--ease), var(--ease), var(--ease), var(--ease), ease-out;
  }
  .indicator__liquid {
    translate: calc(
        (var(--complete) / 100) * (100cqi - 100% - (2 * var(--border)))
      ) -50%;
    transition-property: scale;
    transition-duration: var(--transition);
    transition-timing-function: var(--ease);
  }
  .indicator__liquid :is(.cover, .shadow) {
    transition: opacity var(--transition) var(--ease);
  }
  [data-active='true'] .indicator--masked .mask,
  .liquid-toggle:active .indicator--masked .mask {
    height: calc((100% - (2 * var(--border))) * (1.65 - (var(--delta, 0) * 0.025)));
    width: calc((60% - (2 * var(--border))) * (1.65 + (var(--delta, 0) * 0.025)));
    margin-left: calc((60% - (2 * var(--border))) * ((.65 + (var(--delta, 0) * 0.025)) * -0.5));
  }
  [data-active='true'] .indicator__liquid,
  .liquid-toggle:active .indicator__liquid {
    scale: calc(1.65 + (var(--delta, 0) * 0.025)) calc(1.65 - (var(--delta, 0) * 0.025));
  }

  [data-active='true'] .wrapper,
  .liquid-toggle:active .wrapper {
    filter: blur(0px);
  }

  [data-active='true'] .indicator__liquid .shadow,
  .liquid-toggle:active .indicator__liquid .shadow {
    opacity: 1;
  }

  [data-active='true'] .indicator__liquid .cover,
  .liquid-toggle:active .indicator__liquid .cover {
    opacity: 0;
  }

  [data-active='true'] .indicator__liquid .liquid__track,
  .liquid-toggle:active .indicator__liquid .liquid__track {
    left: calc(var(--border) * 3);
    height: calc((var(--height) * 1px) - (6 * var(--border)));
  }
}

@layer toggle {
  /* Windows 7 Aero CSS Variables */
  :root {
    --w7-surface: #f0f0f0;
    --w7-el-bg: #f2f2f2;
    --w7-el-bg-s-1: #ebebeb;
    --w7-el-bg-s-2: #cfcfcf;
    --w7-el-sd: inset 0 0 0 1px #fffc;
    --w7-el-bd: #8e8f8f;
    --w7-el-bd-h: #3c7fb1;
    --w7-el-bdr: 3px;
    --w7-pg-bg: #00d82c;
  }

  [data-mapped=false] .liquid-toggle {
    --progress: round(down, var(--complete), 85);
    --checked: hsl(
      var(--hue, 144),
      calc((8 + (var(--progress) / 85 * (92))) * 1%),
      calc((81 - (var(--progress) / 85 * (81 - 43))) * 1%)
    );
    .indicator, .indicator--masked {
      transition: background calc(var(--transition) * 0.5) ease-out;
    }
    .liquid__shadow {
      transition: box-shadow calc(var(--transition) * 0.5) ease-out;
    }
  }

  .liquid-toggle {
    --unchecked: hsl(218, 8%, 81%);
    --checked: hsl(
      var(--hue, 144),
      calc((8 + (var(--complete) / 100 * (92))) * 1%),
      calc((81 - (var(--complete) / 100 * (81 - 43))) * 1%)
    );
    --control: hsl(300, 100%, 100%);
    --border: 3px;
    --width: 100;
    --height: 30;
    height: calc(var(--height) * 1px);
    width: calc(var(--width) * 1px);
    border-radius: var(--w7-el-bdr);
    border: 1px solid var(--w7-el-bd);
    padding: 0;
    cursor: pointer;
    position: relative;
    overflow: visible;
    container-type: inline-size;
    background: 
      radial-gradient(circle at 0 50%, #0000001f 5px, transparent 15px),
      radial-gradient(circle at 100% 50%, #0000001f 5px, transparent 15px),
      linear-gradient(180deg, #f3f3f3af, #fcfcfcaf 3px, #dbdbdbaf 6px, #cacacaaf 0, #d5d5d5af),
      #ddd;
    box-shadow: 
      inset 0 0 0 1px #f3f3f388,
      0 0 0 1px #eaeaea88;
    transition: outline var(--transition) var(--ease), border-color var(--transition) var(--ease);
    outline-offset: 2px;
  }

  /* hidden pre-animation state so the control doesn't flash in before pop-in */
  .liquid-toggle.pre-pop {
    opacity: 0;
    transform: translate(-50%, -50%) translate3d(0, 24px, 0) scale(.6) skewX(0) skewY(0);
    filter: blur(6px);
    pointer-events: none;
  }

  @media (prefers-reduced-motion: reduce) {
    .liquid-toggle.pre-pop {
      opacity: 1;
      transform: none;
      filter: none;
      pointer-events: auto;
    }
  }

  /* Full-screen flash overlay used when switch toggles */
  .white-flash-overlay {
    position: fixed;
    inset: 0;
    background: #fff;
    z-index: 99999;
    pointer-events: none;
    /* start with a tiny circle at the toggle position */
    clip-path: circle(0px at 0px 0px);
    transition: clip-path 520ms cubic-bezier(.22,.9,.33,1), opacity 220ms linear;
    opacity: 1;
  }

  /* When page is flashed keep a clean white bg */
  .is-flashed {
    background: #fff !important;
    color: #000 !important;
  }

  @media (prefers-reduced-motion: reduce) {
    .white-flash-overlay { transition: none; }
  }

  .liquid-toggle:focus-visible {
    outline: 4px solid color-mix(in oklch, var(--checked), #0000);
    border-color: var(--w7-el-bd-h);
  }

  .liquid-toggle:active {
    outline: none;
  }
  .liquid-toggle[data-active='true']:focus-visible {
    outline: 4px solid #0000;
  }

  .indicator {
    border-radius: var(--w7-el-bdr);
    pointer-events: none;
    height: 100%;
    width: 100%;
    background-color: var(--w7-pg-bg);
    background-image: 
      linear-gradient(180deg, #f3f3f3af, #fcfcfcaf 3px, #dbdbdbaf 6px, transparent 0),
      radial-gradient(circle at 0 50%, #0000002f 5px, transparent 15px),
      radial-gradient(circle at 100% 50%, #0000002f 5px, transparent 15px),
      linear-gradient(180deg, transparent 65%, #ffffff55),
      linear-gradient(180deg, transparent 6px, #cacaca33 0, #d5d5d533);
    box-shadow: inset 0 0 0 1px #ffffff1f;
    position: absolute;
    top: 50%;
    scale: 1;
    left: 50%;
    translate: -50% -50%;
    clip-path: inset(0 calc(100% - var(--complete) * 1%) 0 0);
    transition: clip-path var(--transition) var(--ease);
  }

  .knockout {
    height: calc(var(--height) * 1px);
    width: calc(var(--width) * 1px);
    border-radius: var(--w7-el-bdr);
    filter: url(#remove-black);
    position: absolute;
    inset: 0;
    will-change: filter, scale;
    transform: translate3d(0, 0, 0);
  }
  .indicator--masked {
    background-color: var(--w7-pg-bg);
    background-image: 
      linear-gradient(180deg, #f3f3f3af, #fcfcfcaf 2px, #dbdbdbaf 4px, transparent 0),
      radial-gradient(circle at 0 50%, #0000002f 5px, transparent 15px),
      radial-gradient(circle at 100% 50%, #0000002f 5px, transparent 15px),
      linear-gradient(180deg, transparent 65%, #ffffff55),
      linear-gradient(180deg, transparent 4px, #cacaca33 0, #d5d5d533);
    box-shadow: inset 0 0 0 1px #ffffff1f;
    z-index: 12;
    height: 100%;
    width: 100%;
    translate: -50% -50%;
    container-type: inline-size;
    border-radius: var(--w7-el-bdr);
    clip-path: inset(0 calc(100% - var(--complete) * 1%) 0 0);
    transition: clip-path var(--transition) var(--ease);

    .mask {
      position: absolute;
      height: calc(100% - (2 * var(--border)));
      width: calc(60% - (2 * var(--border)));
      top: 50%;
      background: #000;
      left: var(--border);
      border-radius: var(--w7-el-bdr);
    }
  }

  .wrapper {
    position: absolute;
    inset: 0;
    border-radius: var(--w7-el-bdr);
  }

  .liquids {
    position: absolute;
    inset: 0;
    transform: translate3d(0, 0, 0);
    border-radius: var(--w7-el-bdr);
    overflow: hidden;
    filter: url(#goo);

    .liquid__shadow {
      position: absolute;
      inset: 0;
      box-shadow: inset 0px 0px 2px 2px var(--w7-pg-bg),
        inset calc(((var(--complete) / 100) * 4px) + -2px) 0px 2px 2px var(--w7-pg-bg);
      border-radius: var(--w7-el-bdr);
    }

    .liquid__track {
      content: '';
      height: calc((var(--height) * 1px) - (0 * var(--border)));
      width: calc((var(--width) * 1px) - (0 * var(--border)));
      background-color: var(--w7-pg-bg);
      background-image: 
        linear-gradient(180deg, transparent 65%, #ffffff55),
        linear-gradient(180deg, transparent 4px, #cacaca33 0, #d5d5d533);
      border-radius: var(--w7-el-bdr);
      position: absolute;
      top: 50%;
    }
  }

  .indicator__liquid {
    position: absolute;
    height: calc(100% - (2 * var(--border)));
    width: calc(60% - (2 * var(--border)));
    container-type: inline-size;
    top: 50%;
    background: #0000;
    left: var(--border);
    border-radius: var(--w7-el-bdr);

    /* watery jello ripple used on initial pop-in */
    --jello-duration: 900ms;

  /* Pop-in (watery jello) animation for the switch */
  @keyframes jello-pop {
    0% {
      transform: translate(-50%, -50%) rotate(var(--rotation,0)) translate3d(0, 24px, 0) scale(.6) skewX(0deg) skewY(0deg);
      opacity: 0;
      filter: blur(6px);
    }
    40% {
      transform: translate(-50%, -50%) rotate(var(--rotation,0)) translate3d(0, -8px, 0) scale(1.18) skewX(-3deg) skewY(3deg);
      opacity: 1;
      filter: blur(2px);
    }
    55% {
      transform: translate(-50%, -50%) rotate(var(--rotation,0)) translate3d(0, 8px, 0) scale(.92) skewX(3deg) skewY(-3deg);
    }
    70% {
      transform: translate(-50%, -50%) rotate(var(--rotation,0)) translate3d(0, -4px, 0) scale(1.06) skewX(-1.5deg) skewY(1.5deg);
    }
    85% {
      transform: translate(-50%, -50%) rotate(var(--rotation,0)) translate3d(0, 2px, 0) scale(.99) skewX(.6deg) skewY(-.6deg);
    }
    100% {
      transform: translate(-50%, -50%) rotate(var(--rotation,0)) translate3d(0, 0, 0) scale(1) skewX(0) skewY(0);
      opacity: 1;
      filter: none;
    }
  }

  /* small inner ripple to make the liquid wobble */
  @keyframes liquid-ripple {
    0% { transform: scaleX(1) scaleY(1); }
    30% { transform: scaleX(1.08) scaleY(.92); }
    55% { transform: scaleX(.92) scaleY(1.06); }
    80% { transform: scaleX(1.03) scaleY(.97); }
    100% { transform: scaleX(1) scaleY(1); }
  }

  /* class toggled on page load */
  .liquid-toggle.pop-in {
    /* stronger rule to ensure animation applies when toggled from console */
    animation-name: jello-pop !important;
    animation-duration: var(--jello-duration) !important;
    animation-timing-function: cubic-bezier(.22,.9,.33,1) !important;
    animation-fill-mode: both !important;
    transform-origin: 50% 50%;
    /* subtle pop shadow so you can see it triggered even if animation is blocked */
    box-shadow: 0 24px 48px rgba(0,0,0,0.12) inset, 0 12px 30px rgba(0,0,0,0.12);
  }

  .liquid-toggle.pop-in .indicator__liquid .liquid__track,
  .liquid-toggle.pop-in .indicator__liquid .liquid__shadow {
    animation-name: liquid-ripple !important;
    animation-duration: var(--jello-duration) !important;
    animation-timing-function: cubic-bezier(.22,.9,.33,1) !important;
    animation-fill-mode: both !important;
    transform-origin: 50% 50%;
  }

  /* Respect user's reduced motion preference */
  @media (prefers-reduced-motion: reduce) {
    .liquid-toggle.pop-in,
    .liquid-toggle.pop-in .indicator__liquid .liquid__track,
    .liquid-toggle.pop-in .indicator__liquid .liquid__shadow {
      animation: none !important;
      transform: none !important;
    }
  }

    .shadow {
      opacity: 0;
      content: '';
      position: absolute;
      inset: 0;
      border-radius: var(--w7-el-bdr);
      box-shadow: 
        1px -1px 2px hsl(0 0% 100% / 0.5) inset,
        0px -1px 2px hsl(0 0% 100% / 0.5) inset,
        -1px -1px 2px hsl(0 0% 100% / 0.5) inset,
        1px 1px 2px hsl(0 0% 30% / 0.5) inset,
        -4px 2px 5px -3px hsl(0 0% 30% / 0.25) inset,
        -1px 1px 3px hsl(0 0% 30% / 0.25) inset,
        -1px -1px 4px hsl(0 0% 60% / 0.15), 
        1px 1px 2px hsl(0 0% 30% / 0.15),
        2px 2px 3px hsl(0 0% 30% / 0.15),
        -2px -1px 2px hsl(0 0% 100% / 0.25) inset,
        2px 3px 8px -3px hsl(0 0% 30% / 0.5);
      z-index: 20;
    }

    .cover {
      content: '';
      position: absolute;
      inset: 0;
      background: 
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAJCAYAAAALpr0TAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAADcSURBVChTNZBLqoUwEEQrURQUxZGCvy24ACfiityJi7tv8GauQoPxk5tquA2RQ9vVVYk6z9NZaxFFEe77htYazjk8z4MwDIVZ+rourOuKaZrwvi+WZcE8z1BKCbPPCjk4DAO2bRP1OI7wLiL6Mbd7J408z1GWpQwWRYGqqiQG+03TgMu0MacfUN4qANmn8UOv9MjW3sKaSm7iIdOSlziOQ3LScd93aPonSYK6riVLlmVo21aYfVqzND9pmqLrOlGT+76XbcxLZkb19/l3fEP+oF0cx8KMEASBsDEGX2/CgZCHkg+8AAAAAElFTkSuQmCC") no-repeat 50%,
        linear-gradient(180deg, var(--w7-el-bg) 45%, var(--w7-el-bg-s-1) 45%, var(--w7-el-bg-s-2));
      background-size: auto, 100% 100%;
      border: 1px solid var(--w7-el-bd);
      border-radius: var(--w7-el-bdr);
      box-shadow: var(--w7-el-sd);
      transition: background var(--transition) var(--ease), border-color var(--transition) var(--ease);
    }

    &:hover .cover {
      background: 
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAJCAYAAAALpr0TAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAADcSURBVChTNZBLqoUwEEQrURQUxZGCvy24ACfiityJi7tv8GauQoPxk5tquA2RQ9vVVYk6z9NZaxFFEe77htYazjk8z4MwDIVZ+rourOuKaZrwvi+WZcE8z1BKCbPPCjk4DAO2bRP1OI7wLiL6Mbd7J408z1GWpQwWRYGqqiQG+03TgMu0MacfUN4qANmn8UOv9MjW3sKaSm7iIdOSlziOQ3LScd93aPonSYK6riVLlmVo21aYfVqzND9pmqLrOlGT+76XbcxLZkb19/l3fEP+oF0cx8KMEASBsDEGX2/CgZCHkg+8AAAAAElFTkSuQmCC") no-repeat 50%,
        linear-gradient(180deg, #eaf6fd 45%, #bee6fd 45%, #a7d9f5);
      background-size: auto, 100% 100%;
      border-color: var(--w7-el-bd-h);
    }
  }
}

@layer base {
  :root {
    --font-size-min: 16;
    --font-size-max: 20;
    --font-ratio-min: 1.2;
    --font-ratio-max: 1.33;
    --font-width-min: 375;
    --font-width-max: 1500;
  }

  html {
    color-scheme: light dark;
  }

  [data-theme='light'] {
    color-scheme: light only;
  }

  [data-theme='dark'] {
    color-scheme: dark only;
  }

  :where(.fluid) {
    --fluid-min: calc(
      var(--font-size-min) * pow(var(--font-ratio-min), var(--font-level, 0))
    );
    --fluid-max: calc(
      var(--font-size-max) * pow(var(--font-ratio-max), var(--font-level, 0))
    );
    --fluid-preferred: calc(
      (var(--fluid-max) - var(--fluid-min)) /
        (var(--font-width-max) - var(--font-width-min))
    );
    --fluid-type: clamp(
      (var(--fluid-min) / 16) * 1rem,
      ((var(--fluid-min) / 16) * 1rem) -
        (((var(--fluid-preferred) * var(--font-width-min)) / 16) * 1rem) +
        (var(--fluid-preferred) * var(--variable-unit, 100vi)),
      (var(--fluid-max) / 16) * 1rem
    );
    font-size: var(--fluid-type);
  }

  *,
  *:after,
  *:before {
    box-sizing: border-box;
  }

  body {
    background: light-dark(#fff, #000);
    display: grid;
    place-items: center;
    min-height: 100vh;
    font-family: 'SF Pro Text', 'SF Pro Icons', 'AOS Icons', 'Helvetica Neue',
      Helvetica, Arial, sans-serif, system-ui;
  }

  .intro,
  .sticky-cols,
  .outro {
    font-family: 'Frutiger', sans-serif;
  }

  .bear-link {
    color: canvasText;
    position: fixed;
    top: 1rem;
    left: 1rem;
    width: 48px;
    aspect-ratio: 1;
    display: grid;
    place-items: center;
    opacity: 0.8;
  }

  :where(.x-link, .bear-link):is(:hover, :focus-visible) {
    opacity: 1;
  }

  .bear-link svg {
    width: 75%;
  }

  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border-width: 0;
  }
}





                        </style>

                        <!-- Merged HTML (from index.html) -->
  <div class="lights-background" id="lightsContainer"></div>
  
  <main>
  <button id="merged-toggle" aria-label="toggle" aria-pressed="false" class="liquid-toggle pre-pop" style="display:none;">
        <div class="arrow arrow--main" style="margin-left: -150px; margin-top: -50px;">
          <span style="color: #605E5FFF;">Open the portal?</span>
        </div>
          <div class="debug debug--knockout">
            <div class="arrow">
              <span>knockout backdrop.</span>
            </div>
            <div class="knockout knockout--debug">
              <div class="indicator indicator--masked">
                <div class="mask"></div>
              </div>
            </div>
          </div>
          <div class="knockout">
            <div class="indicator indicator--masked">
              <div class="mask"></div>
            </div>
          </div>
          <div class="debug debug--indicator">
            <div class="arrow">
              <span>goo window.</span>
            </div>
            <div class="indicator__liquid indicator__liquid--debug">
              <div class="shadow"></div>
              <div class="wrapper">
                <div class="liquids">
                  <div class="liquid__shadow"></div>
                  <div class="liquid__track"></div>
                </div>
              </div>
              <div class="cover"></div>
            </div>
          </div>
          <div class="indicator__liquid">
            <div class="shadow"></div>
            <div class="wrapper">
              <div class="liquids">
                <div class="liquid__shadow"></div>
                <div class="liquid__track"></div>
              </div>
            </div>
            <div class="cover"></div>
          </div>
        </button>
      </main>
      <svg class="sr-only" xmlns="http://www.w3.org/2000/svg">
        <defs>
          <filter id="goo">
            <feGaussianBlur
              id="SvgjsFeGaussianBlur1000"
              result="SvgjsFeGaussianBlur1000"
              in="SourceGraphic"
              stdDeviation="13"
            ></feGaussianBlur>
            <feColorMatrix
              id="SvgjsFeColorMatrix1001"
              result="SvgjsFeColorMatrix1001"
              in="SvgjsFeGaussianBlur1000"
              values="
                  1 0 0 0 0
                  0 1 0 0 0
                  0 0 1 0 0
                  0 0 0 13 -10
              "
              type="matrix"
            ></feColorMatrix>
            <feComposite
              id="SvgjsFeComposite1002"
              result="SvgjsFeComposite1002"
              in="SvgjsFeColorMatrix1001"
              operator="atop"
            ></feComposite>
          </filter>
          <filter id="knockout" colorInterpolationFilters="sRGB">
            <feColorMatrix
              result="knocked"
              type="matrix"
              values="1 0 0 0 0
                      0 1 0 0 0
                      0 0 1 0 0
                      -1 -1 -1 1 0"
            />
            <feComponentTransfer>
              <feFuncR type="linear" slope="3" intercept="-1" />
              <feFuncG type="linear" slope="3" intercept="-1" />
              <feFuncB type="linear" slope="3" intercept="-1" />
            </feComponentTransfer>
            <feComponentTransfer>
              <feFuncR type="table" tableValues="0 0 0 0 0 1 1 1 1 1" />
              <feFuncG type="table" tableValues="0 0 0 0 0 1 1 1 1 1" />
              <feFuncB type="table" tableValues="0 0 0 0 0 1 1 1 1 1" />
            </feComponentTransfer>
          </filter>
          <filter id="remove-black" color-interpolation-filters="sRGB">
            <feColorMatrix
              type="matrix"
              values="1 0 0 0 0
                        0 1 0 0 0
                        0 0 1 0 0
                        -255 -255 -255 0 1"
              result="black-pixels"
            />
            <feMorphology
              in="black-pixels"
              operator="dilate"
              radius="0.5"
              result="smoothed"
            />
            <feComposite in="SourceGraphic" in2="smoothed" operator="out" />
          </filter>
        </defs>
      </svg>
      
  <script>
    // Check if user has visited before using cookies
    const isFirstVisit = !document.cookie.includes("visited=true");
    if (isFirstVisit) {
      console.log("First visit to the site.");
      document.cookie = "visited=true; max-age=31536000; path=/"; // Expires in 1 year
    } else {
      console.log("User has visited the site before.");
    }

    

  // global flag to mute initial audio if user chose so on first run
  window.initiallyMuted = false;
  // track whether the portal toggle animation has already been shown
  window._toggleAnimationPlayed = window._toggleAnimationPlayed || false;
  // if true, run animation when pre-welcome section is next shown
  window._animateToggleOnPreShow = false;

  // main initialization — wrapped so we can delay it on mobile
  function startEverything() {
      const colors = ['blue', 'green', 'pink'];
      const container = document.getElementById('lightsContainer');
      
      function createLight() {
        const light = document.createElement('div');
        light.className = `light ${colors[Math.floor(Math.random() * colors.length)]}`;
        
        const size = Math.random() * 300 + 200;
        light.style.width = `${size}px`;
        light.style.height = `${size}px`;
        light.style.left = `${Math.random() * 100}%`;
        light.style.top = `${Math.random() * 100}%`;
        light.style.animationDelay = `${Math.random() * 2}s`;
        light.style.animationDuration = `${Math.random() * 3 + 3}s`;
        
        container.appendChild(light);
        
        setTimeout(() => {
          light.remove();
        }, 8000);
      }
      
      setInterval(createLight, 800);
      
      for (let i = 0; i < 5; i++) {
        setTimeout(createLight, i * 300);
      }

    // Audio setup with Web Audio API
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    // expose context so we can close it later when welcome begins
    window.portalAudioContext = audioContext;
    const audio = new Audio('sounds/portal.mp3');
    audio.loop = true;
    // allow external code to pause/stop this portal music
    window.portalAudio = audio;
  // small pop sound used for the pop-in animation
  const popSound = new Audio('sounds/pop.mp3');
  popSound.preload = 'auto';
  popSound.volume = 0.9;
  // helper to play pop sound but avoid duplicates when triggered multiple times quickly
  let _lastPopSoundTime = 0;
  function playPopSoundOnce() {
    const now = performance.now();
    const delta = now - _lastPopSoundTime;
    // shorter debounce so legitimate sequential triggers still play
    if (delta < 300) {
      console.log('playPopSoundOnce: debounced (delta=' + Math.round(delta) + 'ms)');
      return;
    }
    _lastPopSoundTime = now;
    if (window.initiallyMuted) { console.log('playPopSoundOnce: initiallyMuted, skipping'); return; }
    if (!popSound) { console.log('playPopSoundOnce: no popSound available'); return; }
    try {
      popSound.currentTime = 0;
      const p = popSound.play();
      if (p && p.catch) {
        p.catch(e => console.log('Pop sound play prevented:', e));
      }
      console.log('playPopSoundOnce: play attempted');
    } catch (e) {
      console.log('Pop sound error:', e);
    }
  }

  // helper for manual testing
  window.forcePopSound = () => { playPopSoundOnce(); console.log('forcePopSound called'); };
    
    const source = audioContext.createMediaElementSource(audio);
    const lowShelf = audioContext.createBiquadFilter();
    const highShelf = audioContext.createBiquadFilter();
    const gainNode = audioContext.createGain();
    
    // Low shelf filter (boost low end)
    lowShelf.type = 'lowshelf';
    lowShelf.frequency.value = 200;
    lowShelf.gain.value = 16; // Boost bass significantly
    
    // High shelf filter (reduce high end)
    highShelf.type = 'highshelf';
    highShelf.frequency.value = 2000;
    highShelf.gain.value = -32; // Cut highs for muffled sound
    
  // Reduce overall volume for "another room" effect (respect initial mute choice)
  gainNode.gain.value = window.initiallyMuted ? 0 : 0.4;
    
    // Connect the audio graph
    source.connect(lowShelf);
    lowShelf.connect(highShelf);
    highShelf.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    // Start audio on first user interaction (respect initial mute choice)
    let audioStarted = false;
    const startAudio = () => {
      if (!audioStarted) {
        audioContext.resume();
        if (!window.initiallyMuted) audio.play().catch(e => console.log('Audio play failed:', e));
        audioStarted = true;
      }
    };
    
    document.addEventListener('click', startAudio, { once: true });
    document.addEventListener('touchstart', startAudio, { once: true });
    document.addEventListener('keydown', startAudio, { once: true });
    
    // Listen for toggle state changes
    const toggle = document.querySelector('.liquid-toggle');
    if (toggle) {
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.attributeName === 'aria-pressed') {
            const isPressed = toggle.getAttribute('aria-pressed') === 'true';
            const currentTime = audioContext.currentTime;
            
            // Cancel any scheduled changes
            lowShelf.gain.cancelScheduledValues(currentTime);
            highShelf.gain.cancelScheduledValues(currentTime);
            gainNode.gain.cancelScheduledValues(currentTime);
            
            // Set current values
            lowShelf.gain.setValueAtTime(lowShelf.gain.value, currentTime);
            highShelf.gain.setValueAtTime(highShelf.gain.value, currentTime);
            gainNode.gain.setValueAtTime(gainNode.gain.value, currentTime);
            
            if (isPressed) {
              // Transition to normal audio over 2 seconds
              lowShelf.gain.linearRampToValueAtTime(0, currentTime + 2);
              highShelf.gain.linearRampToValueAtTime(0, currentTime + 2);
              gainNode.gain.linearRampToValueAtTime(1, currentTime + 2);
            } else {
              // Transition back to muffled over 2 seconds
              lowShelf.gain.linearRampToValueAtTime(12, currentTime + 2);
              highShelf.gain.linearRampToValueAtTime(-18, currentTime + 2);
              gainNode.gain.linearRampToValueAtTime(0.4, currentTime + 2);
            }
            // create a bright flash that expands from the toggle
            triggerWhiteFlash(isPressed);
          }
        });
      });
      
      observer.observe(toggle, { attributes: true });

      // Flash effect: expands white circle from toggle to fill viewport and leave page white
      function triggerWhiteFlash(activate) {
        console.log('triggerWhiteFlash called, activate=', activate);
        // respect reduced motion — if reduced, just set page to white immediately
        const reduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        const body = document.body;
        let redirected = false;
        const redirectAfterFade = () => {
          if (redirected) return;
          redirected = true;
          // also hide pre-welcome and start welcome if available
          if (typeof hidePreWelcomeAndStartWelcome === 'function') {
              hidePreWelcomeAndStartWelcome();
          }
        };

        if (!activate) {
          // If turning off, remove flashed state
          if (body.classList.contains('is-flashed')) {
            body.classList.remove('is-flashed');
          }
          return;
        }

        if (reduced) {
          body.classList.add('is-flashed');
          redirectAfterFade();
          return;
        }

        // Sound warning dialog shown on first visit

        // compute center of toggle
        const rect = toggle.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;

        // compute farthest corner distance
        const w = Math.max(cx, window.innerWidth - cx);
        const h = Math.max(cy, window.innerHeight - cy);
        const radius = Math.hypot(w, h);

        // create overlay (remove existing if any)
        let overlay = document.querySelector('.white-flash-overlay');
        if (overlay) overlay.remove();
        overlay = document.createElement('div');
        overlay.className = 'white-flash-overlay';

        // set critical inline styles to avoid depending on external CSS loading
        overlay.style.position = 'fixed';
        overlay.style.inset = '0';
        overlay.style.background = '#fff';
        overlay.style.zIndex = '2147483647';
        overlay.style.pointerEvents = 'none';
        overlay.style.opacity = '0';
        overlay.style.clipPath = `circle(0px at ${cx}px ${cy}px)`;
        overlay.style.transition = 'clip-path 520ms cubic-bezier(.22,.9,.33,1), opacity 220ms linear';

  // append to body for consistent stacking
  document.body.appendChild(overlay);

        // debug: log overlay presence and computed style
        console.log('overlay appended:', !!overlay, overlay.getBoundingClientRect());
        console.log('support clip-path?', CSS && CSS.supports && CSS.supports('clip-path', 'circle(1px at 0 0)'));

        // force paint
        overlay.getBoundingClientRect();

        // expand to fill and fade in
        requestAnimationFrame(() => {
          overlay.style.opacity = '1';
          // if clip-path isn't supported, fallback to immediate full white
          if (!(CSS && CSS.supports && CSS.supports('clip-path', 'circle(1px at 0 0)'))) {
            overlay.style.clipPath = `circle(${Math.ceil(radius)}px at ${cx}px ${cy}px)`;
            // short timeout to ensure visuals update
            setTimeout(() => {
              body.classList.add('is-flashed');
              redirectAfterFade();
            }, 50);
            return;
          }

          overlay.style.clipPath = `circle(${Math.ceil(radius)}px at ${cx}px ${cy}px)`;
        });

        let done = false;
        overlay.addEventListener('transitionend', (ev) => {
          if (done) return;
          // accept any transitionend on the overlay; clip-path support varies
          done = true;
          body.classList.add('is-flashed');
          // leave overlay in place so white stays visible until navigation
          redirectAfterFade();
        }, { once: true });

        // Non-event fallback: if transitionend never fires, mark flashed after expected duration and redirect
        const expected = 520; // matches clip-path transition duration
        setTimeout(() => {
          if (done) return;
          done = true;
          body.classList.add('is-flashed');
          redirectAfterFade();
        }, expected + 120);
      }

      // expose function for manual testing
      window.triggerWhiteFlash = (activate = true) => triggerWhiteFlash(activate);

    // Load interaction module and any other modules that should run after initialization
  import('./scripts.js?v=2').catch(e => console.log('Failed to load interactions:', e));

    // Try to autoplay background audio (best-effort). If browser blocks autoplay this will be caught
    // and audio will still start on first user interaction via startAudio(). We apply a short gain ramp
    // so the music fades in instead of popping loud.
    if (!window.initiallyMuted) {
      (async () => {
        try {
          await audioContext.resume();
          await audio.play();
          audioStarted = true;
          const now = audioContext.currentTime;
          // start from 0 then ramp to the target level over 2 seconds for a smooth entrance
          try {
            gainNode.gain.cancelScheduledValues(now);
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(0.08, now + 2);
          } catch (e) {
            console.log('Gain scheduling failed:', e);
          }
          console.log('Background audio autoplayed');
        } catch (err) {
          console.log('Background audio autoplay blocked or failed:', err);
        }
      })();
    }

      // Helper invoked on demand to animate the portal toggle.  Most callers
      // use `showPortalToggleOnce()`, but we keep this small wrapper for
      // compatibility with older logic.
      const schedulePopIn = () => {
        if (window.showPortalToggleOnce) window.showPortalToggleOnce();
      };

      // previously we scheduled this on `load`; now calling is explicit when the
      // portal section opens (via showPre) so no automatic listener is required.
      // if (document.readyState === 'complete') schedulePopIn();
      // else window.addEventListener('load', schedulePopIn, { once: true });

      // Ensure the toggle isn't left in a broken pre-pop state.
      // Sometimes when first-run dialogs/videos run, the initial reveal can get skipped —
      // we defensively reset and retrigger the pop-in a short time after initialization.
      function ensureToggleHealthy() {
        // reuse the explicit show logic; if the portal is visible and we haven't
        // animated yet, this will run the animation and set the flag.
        const pre = document.getElementById('pre-welcome-page');
        if (!pre || getComputedStyle(pre).display === 'none') return;
        if (window.showPortalToggleOnce) {
          window.showPortalToggleOnce();
        }
      }

      // Run defensive check shortly after everything initializes and also expose for debugging
      setTimeout(ensureToggleHealthy, 600);
      window.ensureToggleHealthy = ensureToggleHealthy;

  // ensure pre-pop is cleared if any animation starts
  toggle.addEventListener('animationstart', () => {
    toggle.classList.remove('pre-pop');
    // ensure pop sound plays once when CSS animation starts
    playPopSoundOnce();
  });

      // remove the class after the animation finishes to keep DOM clean
      toggle.addEventListener('animationend', (e) => {
        if (e.animationName === 'jello-pop') toggle.classList.remove('pop-in');
      });

      // Expose a robust trigger for debugging — tries CSS class then falls back to Web Animations
      window.triggerJello = () => {
        const el = document.querySelector('.liquid-toggle');
        if (!el) return console.log('switch not found');

        if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
          console.log('prefers-reduced-motion: reduce — skipping animation');
          return;
        }

  // ensure element isn't stuck hidden
  el.classList.remove('pre-pop');
        // ensure element isn't stuck hidden
        el.classList.remove('pre-pop');
        // retrigger CSS animation
        el.classList.remove('pop-in');
        void el.offsetWidth; // force reflow
        el.classList.add('pop-in');

        // play pop sound (debounced) when animation starts
        playPopSoundOnce();

        const cssAnim = getComputedStyle(el).animationName;
        if (cssAnim && cssAnim !== 'none') {
          console.log('CSS animation applied:', cssAnim);
          return;
        }

        // Fallback: use Web Animations API for visible effect
        console.log('CSS animation not applied; using Web Animations fallback');
        const duration = 900;
        const easing = 'cubic-bezier(.22,.9,.33,1)';

        const jelloFrames = [
          { transform: 'translate3d(0,24px,0) scale(.6) skewX(0) skewY(0)', opacity: 0, filter: 'blur(6px)' },
          { offset: 0.4, transform: 'translate3d(0,-8px,0) scale(1.18) skewX(-3deg) skewY(3deg)', opacity: 1, filter: 'blur(2px)' },
          { offset: 0.55, transform: 'translate3d(0,8px,0) scale(.92) skewX(3deg) skewY(-3deg)' },
          { offset: 0.7, transform: 'translate3d(0,-4px,0) scale(1.06) skewX(-1.5deg) skewY(1.5deg)' },
          { offset: 0.85, transform: 'translate3d(0,2px,0) scale(.99) skewX(.6deg) skewY(-.6deg)' },
          { transform: 'translate3d(0,0,0) scale(1) skewX(0) skewY(0)', opacity: 1, filter: 'none' }
        ];

        el.animate(jelloFrames, { duration, easing, fill: 'forwards' });

        // play pop sound (debounced) for WAAPI fallback as well
        playPopSoundOnce();

        const inner = el.querySelector('.liquid__track');
        if (inner) {
          const ripple = [
            { transform: 'scaleX(1) scaleY(1)' },
            { offset: 0.3, transform: 'scaleX(1.08) scaleY(.92)' },
            { offset: 0.55, transform: 'scaleX(.92) scaleY(1.06)' },
            { offset: 0.8, transform: 'scaleX(1.03) scaleY(.97)' },
            { transform: 'scaleX(1) scaleY(1)' }
          ];
          inner.animate(ripple, { duration, easing, fill: 'forwards' });
        }
      };
      }
      
    }

    // Detect mobile devices and show a scoped Win7-styled overlay if mobile
    const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    function showMobileBlockScreenScoped() {
      // ensure scoped stylesheet is loaded (safe to add globally because it's scoped under .win7)
      const scopedHref = 'https://unpkg.com/7.css/dist/7.scoped.css';
      if (![...document.styleSheets].some(s => s.href && s.href.includes('7.css/dist/7.scoped.css'))) {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = scopedHref;
        link.crossOrigin = 'anonymous';
        link.onload = () => console.log('7.scoped.css loaded');
        link.onerror = () => console.log('Failed to load 7.scoped.css');
        document.head.appendChild(link);
      }

    // create overlay
    const overlay = document.createElement('div');
    overlay.className = 'mobile-block-overlay';
    overlay.style.position = 'fixed';
    overlay.style.inset = '0';
    overlay.style.zIndex = '2147483646';
    overlay.style.display = 'flex';
    overlay.style.alignItems = 'center';
    overlay.style.justifyContent = 'center';
    overlay.style.padding = '20px';
    overlay.style.background = 'transparent';

    // background video for mobile block screen (muted so autoplay is allowed on most browsers)
    const mbBg = document.createElement('video');
    mbBg.src = 'videos/bg.mp4';
    mbBg.muted = true;
    mbBg.autoplay = true;
    mbBg.loop = true;
    mbBg.playsInline = true;
    mbBg.preload = 'auto';
    mbBg.style.position = 'absolute';
    mbBg.style.inset = '0';
    mbBg.style.width = '100%';
    mbBg.style.height = '100%';
    mbBg.style.objectFit = 'cover';
    mbBg.style.zIndex = '2147483646';
    mbBg.style.filter = 'brightness(.45)';
    // attempt to play immediately; muted should allow autoplay on mobile
    mbBg.play().catch(e => console.log('mobile bg.mp4 autoplay failed:', e));

      // content using .win7 wrapper per 7.css docs
      const content = document.createElement('div');
      content.className = 'win7';
      content.innerHTML = `
        <div class="window active" style="width: min(560px, 95%);">
          <div class="title-bar">
            <div class="title-bar-text">Best viewed on PC</div>
            <div class="title-bar-controls">
              <button aria-label="Close" class="is-close" id="mb-close-top"></button>
            </div>
          </div>
          <div class="window-body has-space">
            <div style="display:flex; gap:1rem; align-items:center;">
              <img src="/images/icons/pcIcon.png" alt="PC recommended" style="width:64px;height:64px;object-fit:contain;" />
              <div>
                <p style="margin:0">This site has audio and advanced animations that work best on a PC. For the full experience, please open the site on a desktop or laptop.</p>
              </div>
            </div>
            <div style="display:flex; gap:12px; justify-content:flex-end; margin-top:1rem;">
              <button id="mb-run" class="default">Run anyway</button>
            </div>
          </div>
        </div>
      `;

  // append background video then content so dialog sits above
  overlay.appendChild(mbBg);
  content.style.zIndex = '2147483647';
  overlay.appendChild(content);
      document.body.appendChild(overlay);

      const runBtn = overlay.querySelector('#mb-run');
      // run button behavior
      runBtn.addEventListener('click', () => {
        // stop background video if present
        try { const v = overlay.querySelector('video'); if (v) { v.pause(); v.src = ''; } } catch (e) {}
        overlay.remove();
        startEverything();
      });

      // make the red X behave the same as Run anyway
      const closeTop = overlay.querySelector('#mb-close-top');
      if (closeTop) {
        closeTop.addEventListener('click', () => {
          try { const v = overlay.querySelector('video'); if (v) { v.pause(); v.src = ''; } } catch (e) {}
          overlay.remove();
          startEverything();
        });
      }

      // ensure text and titles are readable (override any dark/white colors)
      const textElems = overlay.querySelectorAll('h2, p, .title-bar-text');
      textElems.forEach(el => (el.style.color = '#111'));
    }

    // Show the audio notice overlay on every visit; play the intro video only on first visit.
    function continueApp() {
      if (isMobileDevice) showMobileBlockScreenScoped(); else startEverything();
    }

    // always show the audio notice; pass `isFirstVisit` so the intro video can be gated
    showSoundWarning(continueApp, isFirstVisit);

    // Sound warning / audio-notice dialog (always shown). `playIntro` controls whether the intro video runs.
    function showSoundWarning(onDone, playIntro = false) {
      // ensure 7.css scoped stylesheet is loaded so the dialog uses Win7 styles
      const scopedHref = 'https://unpkg.com/7.css/dist/7.scoped.css';
      const hasScoped = [...document.styleSheets].some(s => s.href && s.href.includes('7.css/dist/7.scoped.css'));

  const createOverlay = () => {
  const overlay = document.createElement('div');
  overlay.style.position = 'fixed';
  overlay.style.inset = '0';
  overlay.style.zIndex = '2147483650';
  overlay.style.display = 'flex';
  overlay.style.alignItems = 'center';
  overlay.style.justifyContent = 'center';
  overlay.style.background = 'transparent';

  // background video (muted) for the warning screen — plays silently and loops
  const bgVideo = document.createElement('video');
  bgVideo.src = 'videos/bg.mp4';
  bgVideo.autoplay = true;
  bgVideo.muted = true; // muted so browsers allow autoplay
  bgVideo.loop = true;
  bgVideo.playsInline = true;
  bgVideo.preload = 'auto';
  bgVideo.style.position = 'absolute';
  bgVideo.style.inset = '0';
  bgVideo.style.width = '100%';
  bgVideo.style.height = '100%';
  bgVideo.style.objectFit = 'cover';
  bgVideo.style.zIndex = '2147483650';
  bgVideo.style.opacity = '1';
  // darken the video so dialog text remains readable
  bgVideo.style.filter = 'brightness(.46)';

  const wrapper = document.createElement('div');
  wrapper.className = 'win7';
  wrapper.style.maxWidth = '560px';
  wrapper.style.width = 'min(95%, 560px)';
  wrapper.style.zIndex = '2147483651';
        wrapper.innerHTML = `
          <div class="window active">
            <div class="title-bar">
              <div class="title-bar-text">Audio notice</div>
            </div>
            <div class="window-body has-space">
              <div style="display:flex; gap:1rem; align-items:center;">
                <img src="/images/icons/music.webp" alt="Audio" style="width:96px;height:96px;object-fit:contain;" />
                <div>
                  <p style="margin:0; color:#111;">This website plays audio. Please lower your volume if its on max, or unmute your device if its muted, before continuing.</p>
                </div>
              </div>
              <div style="display:flex; gap:12px; justify-content:flex-end; margin-top:1rem;">
                <button id="sound-ok" class="default">Got it</button>
              </div>
            </div>
          </div>
        `;

  // append video behind the dialog
  overlay.appendChild(bgVideo);
  overlay.appendChild(wrapper);
  // try to play (best-effort), log failures
  bgVideo.play().catch(e => console.log('bg.mp4 autoplay blocked or failed:', e));
        document.body.appendChild(overlay);

        const ok = overlay.querySelector('#sound-ok');

        if (ok) {
          ok.addEventListener('click', async () => {
            // mark that we want the portal toggle to animate when the pre section shows
            window._animateToggleOnPreShow = true;

            // remove the audio notice overlay
            overlay.remove();

            // If this is NOT the user's first visit, skip the intro video and continue immediately.
            if (!playIntro) {
              if (onDone) onDone();
              return;
            }

            // play intro video fully (user-initiated click — allowed to play on first visit)
            const vOverlay = document.createElement('div');
            vOverlay.style.position = 'fixed';
            vOverlay.style.inset = '0';
            vOverlay.style.zIndex = '2147483660';
            vOverlay.style.display = 'flex';
            vOverlay.style.alignItems = 'center';
            vOverlay.style.justifyContent = 'center';
            vOverlay.style.background = '#000';

            const video = document.createElement('video');
            video.src = 'videos/weWereLiedTo.mp4';
            video.autoplay = false; // we'll call play() explicitly
            video.playsInline = true;
            video.controls = false;
            video.preload = 'auto';
            video.volume = 0.25;
            video.style.maxWidth = '100%';
            video.style.maxHeight = '100%';
            video.style.width = '100%';
            video.style.height = '100%';

            vOverlay.appendChild(video);
            // initial background is black; we'll fade it to white near the end of the video
            vOverlay.style.background = '#000';
            vOverlay.style.transition = '';
            document.body.appendChild(vOverlay);

            try {
              await video.play();
            } catch (err) {
              console.log('Intro video play failed or was blocked:', err);
              // fall back to continuing the app
              vOverlay.remove();
              if (onDone) onDone();
              return;
            }

            // fade overlay background to white between 0:47 and 0:49
            let fadeStarted = false;
            const fadeStart = 46.67;
            const fadeDuration = 2; // seconds
            const onTime = () => {
              const t = video.currentTime;
              if (!fadeStarted && t >= fadeStart) {
                fadeStarted = true;
                // trigger a smooth background transition to white that finishes at fadeStart + fadeDuration
                vOverlay.style.transition = `background ${fadeDuration}s linear`;
                vOverlay.style.background = '#fff';
              }
            };
            video.addEventListener('timeupdate', onTime);

            // when video ends, remove overlay and continue
            video.addEventListener('ended', () => {
              video.removeEventListener('timeupdate', onTime);
              vOverlay.remove();
              if (onDone) onDone();
            }, { once: true });
          });

          // keyboard accessibility: Enter/Space should also activate
          ok.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              ok.click();
            }
          });
        }
      };

      if (hasScoped) {
        createOverlay();
      } else {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = scopedHref;
        link.crossOrigin = 'anonymous';
        let called = false;
        link.onload = () => { if (!called) { called = true; createOverlay(); console.log('7.scoped.css loaded for sound dialog'); } };
        link.onerror = () => { if (!called) { called = true; console.log('Failed to load 7.scoped.css for sound dialog — falling back'); createOverlay(); } };
        // fallback: ensure overlay shows even if stylesheet is slow
        setTimeout(() => { if (!called) { called = true; console.log('7.scoped.css load timeout — showing dialog'); createOverlay(); } }, 800);
        document.head.appendChild(link);
      }
    }
  </script>
<script>
(function(){
    // hide pre-welcome and start the welcome sequence
    function hidePreWelcomeAndStartWelcome() {
        // mark that welcome may now run
        window._allowWelcome = true;
        const pre = document.getElementById('pre-welcome-page');
        if (pre) pre.style.display = 'none';
        // clear any white‑flash remnants so the welcome screen is visible
        document.body.classList.remove('is-flashed');
        const overlay = document.querySelector('.white-flash-overlay');
        if (overlay) overlay.remove();
        // stop portal music if playing
        try {
            if (window.portalAudio) {
                window.portalAudio.pause();
                window.portalAudio.src = '';
                window.portalAudio = null;
            }
            if (window.portalAudioContext) {
                window.portalAudioContext.close().catch(() => {});
                window.portalAudioContext = null;
            }
        } catch (e) {
            console.log('error stopping portal audio', e);
        }
        if (window.startWelcome) window.startWelcome();
    }

    const toggle = document.getElementById('merged-toggle');
    const cont = document.getElementById('pre-welcome-continue');
    if (!toggle && !cont) return;

    // ensure global flag is available
    window._toggleAnimationPlayed = window._toggleAnimationPlayed || false;

    // show toggle with animation once (called explicitly when portal appears)
    function showPortalToggleOnce() {
        if (!toggle || window._toggleAnimationPlayed) return;
        window._toggleAnimationPlayed = true;
        toggle.style.display = '';
        toggle.classList.remove('pre-pop');
        toggle.classList.add('pop-in');
        toggle.style.pointerEvents = 'auto';
        // remove animation class after it finishes, but keep element visible
        toggle.addEventListener('animationend', () => {
            toggle.classList.remove('pop-in');
        }, { once: true });
    }
    window.showPortalToggleOnce = showPortalToggleOnce;

    function triggerWhiteFlash() {
        const overlay = document.createElement('div');
        overlay.className = 'white-flash-overlay';
        overlay.style.zIndex = 2147483647;
        document.body.appendChild(overlay);

        const rect = toggle.getBoundingClientRect();
        const cx = Math.round(rect.left + rect.width/2);
        const cy = Math.round(rect.top + rect.height/2);
        const dx = Math.max(cx, window.innerWidth - cx);
        const dy = Math.max(cy, window.innerHeight - cy);
        const radius = Math.ceil(Math.sqrt(dx*dx + dy*dy));

        overlay.getBoundingClientRect();
        requestAnimationFrame(() => {
            overlay.style.clipPath = `circle(${radius}px at ${cx}px ${cy}px)`;
            overlay.style.opacity = '1';
        });

        let done = false;
        overlay.addEventListener('transitionend', function() {
            if (done) return; done = true;
            overlay.remove();
            hidePreWelcomeAndStartWelcome();
        }, { once: true });

        setTimeout(() => {
            if (!done) { done = true; overlay.remove(); hidePreWelcomeAndStartWelcome(); }
        }, 800);
    }

    function toggleState() {
        const pressed = toggle.getAttribute('aria-pressed') === 'true';
        toggle.setAttribute('aria-pressed', (!pressed).toString());
        toggle.classList.remove('pre-pop');
        toggle.classList.add('pop-in');
        setTimeout(() => { triggerWhiteFlash(); }, 520);
    }

    toggle && toggle.addEventListener('click', toggleState);
    cont && cont.addEventListener('click', hidePreWelcomeAndStartWelcome);
    window.mergedTriggerWhiteFlash = triggerWhiteFlash;
})();
</script>
                    </div>
                </div>


        <!-- Welcome Splash Screen -->
        <canvas id="welcome-splash" style="position: fixed; inset: 0; width: 100vw; height: 100vh; z-index: 9999;">
                Your browser does not support canvas.
        </canvas>
        <div id="glass-icons-container">
            <div class="glass-icon-top-row">
                <img id="glass-icon-start" src="images/icons/starthover.png" alt="" />
                <div class="glass-icon-right-stack">
                    <img id="glass-icon-horizon" src="images/Horizon-OS.png" alt="" />
                    <img id="glass-icon-version" src="images/1.0.png" alt="" />
                    <h1 style="font-family: 'Frutiger'; font-size: 1rem; margin-top: 0.1rem;">Common World Institute of Technology</h1>
                </div>
            </div>
            <div class="glass-icon-bottom-row">
                <img src="images/icons/internet.png" alt="" />
                <img src="images/icons/run-build-configure.svg" alt="" />
                <img src="images/icons/mouse.png" alt="" />
                <img src="images/icons/multiWindows.svg" alt="" />
                <img src="images/icons/laptop.png" alt="" />
                <img src="images/icons/seperation.png" alt="" />
                <img src="images/icons/system-software-update.svg" alt="" />
            </div>
            <div id="debugging" style="background-color: black; width: 28rem ;margin: auto; margin-top: 0.5rem; padding: 0.5rem; border-radius: 0.5rem;">
                
            </div>
        
        </div>
        <div id="welcome-progressbar" class="win7" style="position: fixed; left: 50%; bottom: 0; transform: translateX(-50%); width: calc(100vw + 32px); margin: 0; padding: 0; z-index: 10002; pointer-events: none;">
            <div role="progressbar" class="marquee" style="margin: 0; width: 100%; border-radius: 0;"></div>
        </div>
        </div>
        <img
                id="welcome-splash-image"
                src="images/welcomeBG.png"
                alt=""
        />

        <script id="welcome-splash-shader" type="x-shader/x-fragment">
            precision mediump float;

            uniform vec3 iResolution;
            uniform float iTime;
            uniform vec4 iMouse;
            uniform sampler2D iChannel0;

            void mainImage(out vec4 fragColor, in vec2 fragCoord)
            {
                const float NUM_ZERO = 0.0;
                const float NUM_ONE = 1.0;
                const float NUM_HALF = 0.5;
                const float NUM_TWO = 2.0;
                const float POWER_EXPONENT = 6.0;
                const float LENS_SIZE_SCALE = 1.2;
                const float LENS_WIDTH_PADDING = 0.1;
                const float MASK_MULTIPLIER_1 = 2500.0;
                const float MASK_MULTIPLIER_2 = 2300.0;
                const float MASK_MULTIPLIER_3 = 2700.0;
                const float LENS_MULTIPLIER = 1400.0;
                const float MASK_STRENGTH_1 = 8.0;
                const float MASK_STRENGTH_2 = 16.0;
                const float MASK_STRENGTH_3 = 2.0;
                const float MASK_THRESHOLD_1 = 0.95;
                const float MASK_THRESHOLD_2 = 0.9;
                const float MASK_THRESHOLD_3 = 1.5;
                const float SAMPLE_RANGE = 4.0;
                const float SAMPLE_OFFSET = 0.5;
                const float GRADIENT_RANGE = 0.2;
                const float GRADIENT_OFFSET = 0.1;
                const float GRADIENT_EXTREME = -1000.0;
                const float LIGHTING_INTENSITY = 0.3;

                vec2 uv = fragCoord / iResolution.xy;
                vec2 mouse = iMouse.xy;
                vec2 m2 = (uv - mouse / iResolution.xy);
                vec2 m2Scaled = m2 * LENS_SIZE_SCALE;

                float ax = abs(m2Scaled.x * iResolution.x / iResolution.y);
                float ay = abs(m2Scaled.y);
                float roundedBox = pow(max(NUM_ZERO, ax - LENS_WIDTH_PADDING), POWER_EXPONENT) + pow(ay, POWER_EXPONENT);
                float rb1 = clamp((NUM_ONE - roundedBox * MASK_MULTIPLIER_1) * MASK_STRENGTH_1, NUM_ZERO, NUM_ONE);
                float rb2 = clamp((MASK_THRESHOLD_1 - roundedBox * MASK_MULTIPLIER_2) * MASK_STRENGTH_2, NUM_ZERO, NUM_ONE) -
                    clamp(pow(MASK_THRESHOLD_2 - roundedBox * MASK_MULTIPLIER_2, NUM_ONE) * MASK_STRENGTH_2, NUM_ZERO, NUM_ONE);
                float rb3 = clamp((MASK_THRESHOLD_3 - roundedBox * MASK_MULTIPLIER_3) * MASK_STRENGTH_3, NUM_ZERO, NUM_ONE) -
                    clamp(pow(NUM_ONE - roundedBox * MASK_MULTIPLIER_3, NUM_ONE) * MASK_STRENGTH_3, NUM_ZERO, NUM_ONE);

                fragColor = vec4(NUM_ZERO);
                float transition = smoothstep(NUM_ZERO, NUM_ONE, rb1 + rb2);

                if (transition > NUM_ZERO) {
                    float lensAmount = max(NUM_ZERO, NUM_ONE - roundedBox * LENS_MULTIPLIER);
                    vec2 lens = ((uv - NUM_HALF) * lensAmount + NUM_HALF);
                    float total = NUM_ZERO;
                    for (float x = -SAMPLE_RANGE; x <= SAMPLE_RANGE; x++) {
                        for (float y = -SAMPLE_RANGE; y <= SAMPLE_RANGE; y++) {
                            vec2 offset = vec2(x, y) * SAMPLE_OFFSET / iResolution.xy;
                            fragColor += texture2D(iChannel0, offset + lens);
                            total += NUM_ONE;
                        }
                    }
                    fragColor /= total;

                    float gradient = clamp((clamp(m2.y, NUM_ZERO, GRADIENT_RANGE) + GRADIENT_OFFSET) / NUM_TWO, NUM_ZERO, NUM_ONE) +
                        clamp((clamp(-m2.y, GRADIENT_EXTREME, GRADIENT_RANGE) * rb3 + GRADIENT_OFFSET) / NUM_TWO, NUM_ZERO, NUM_ONE);
                    vec4 lighting = clamp(fragColor + vec4(rb1) * gradient + vec4(rb2) * LIGHTING_INTENSITY, NUM_ZERO, NUM_ONE);

                    fragColor = mix(texture2D(iChannel0, uv), lighting, transition);
                } else {
                    fragColor = texture2D(iChannel0, uv);
                }
            }

            void main() {
                mainImage(gl_FragColor, gl_FragCoord.xy);
            }
        </script>
    
    <main>

            <div class="notification flyout col-content-wrapper liquid-glass" style="left: 82%; top: 15%;">
                <div class="liquid-glass--bend"></div>
                <div class="liquid-glass--face"></div>
                <div class="liquid-glass--edge"></div>
                <h2>Notification LOL</h2>
                <p>asdfasdgdgh  sdgf</p>
            </div>

            <div class="music flyout col-content-wrapper liquid-glass" style="left: 82%; top: 15%;">
                <div class="liquid-glass--bend"></div>
                <div class="liquid-glass--face"></div>
                <div class="liquid-glass--edge"></div>

                <div style="background-color: rgba(50, 50, 50, 0.7); padding: 1rem; border-radius: 0.5rem;font-weight: 100;">
                    <p style="color: rgb(180, 180, 180);" id="lastSong"></p>
                    <h2 style="margin-top: 0.01rem; margin-bottom: 0.1rem; color:white;">Now Playing</h2>
                    <p style="color:white;" id="currentSong"></p>
                    <p style="color: rgb(180, 180, 180);" id="nextSong"></p>
                </div>
                <img id="cdImage" class="cd-spinning" src="images/cd.png" style="width: 75%; height: 50%; margin-bottom: 1rem; margin: auto;top: 1rem;" alt="Album Art">
                <div class="music-player-controls" style="margin: auto;top: 2rem;">
                  <button id="audioBack" title="Previous song" style="background: none; border: none; margin-right: 1rem;">
                    <img src="images/icons/music/music_player_back.png" alt="Music Player - Back Button">
                  </button>

                  <button id="audioPlayPause" title="Play / Pause" style="background: none; border: none; width: 2.5rem; height: 2.5rem; margin-right: 1rem;">
                    <img src="images/icons/music/music_player_play.png" id="audioPlayPauseImage" alt="Music Player - Play / Pause Button">
                  </button>

                  <button id="audioForward" title="Next song" style="background: none; border: none;">
                    <img src="images/icons/music/music_player_forward.png" alt="Music Player - Forward Button">
                  </button>
                </div>
            </div>

        <section class="intro">
            <div class="intro-visualiser" aria-hidden="true">
                <canvas id="introVisualiserCanvas"></canvas>
            </div>
            <div class="intro-top-right" style="color: #F86BC7; position: absolute; top: 2rem; right: 0; width: 50%; height: 50%; display: flex; flex-direction: column; align-items: flex-end; justify-content: flex-start; padding: 2rem; box-sizing: border-box;">
                <div class="window-wrapper no-padding" style="opacity: 1; z-index: 1; top: 2rem; right: 2rem; min-width: 360px;">
                    <div class="window colored glass">
                        <div class="title-bar dbl-maximize">
                            <div class="title-bar-text">SAKURA - Archived Utopia</div>
                            <div class="title-bar-controls">
                                <button aria-label="Minimize" class="minimize"></button>
                                <button aria-label="Maximize" class="maximize"></button>
                                <button aria-label="Close" class="close"></button>
                            </div>
                        </div>
                        <div class="window-body">
                            <div class="notepad-container" contenteditable=""><pre>
                                <h1>Not Just A Base</h1>
                                <p>This is a fully automated, eco-integrated logistics hub</p>
                            </pre>
                            </div>
                        </div>
                    </div>
                </div>                
            </div>
            <div class="intro-bottom-left" style="color: #4577ea; position: absolute; top: 50%; left: 0; width: 50%; height: 50%; display: flex; flex-direction: column; align-items: flex-start; justify-content: flex-end; padding: 2rem; box-sizing: border-box;">
                <div class="window-wrapper no-padding" style="opacity: 1; z-index: 1; top: 100rem; left: 354px; min-width: 360px;">
                    <div class="window colored glass">
                        <div class="title-bar dbl-maximize">
                            <div class="title-bar-text">SAKURA - Archived Utopia</div>
                            <div class="title-bar-controls">
                                <button aria-label="Minimize" class="minimize"></button>
                                <button aria-label="Maximize" class="maximize"></button>
                                <button aria-label="Close" class="close"></button>
                            </div>
                        </div>
                        <div class="window-body">
                            <div class="notepad-container" contenteditable=""><pre>
                                <h1>Eco-friendly</h1>
                                <p>A Sky Base that does not affect the Ground Ecosystem</p>
                            </pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div style="position: relative; width: 100%; height: 300px;"></div>
            <!-- taskbar backdrop lives inside .intro so we can emulate backdrop-filter when
                 the taskbar becomes fixed. JS will size/position this element. -->
            <div class="taskbar-blur-backdrop" aria-hidden="true"></div>
        </section>

    <!-- Start menu and taskbar (embedded from example). Placed after .intro so the
         taskbar appears at the bottom of the intro as a normal element and becomes
         sticky when it reaches the top of the viewport. -->
    <div class="start-menu" id="spotlight-menu">
        <div class="colored glass window">
            <div class="title-bar">
                <div class="custom spotlight-container window-body">
                    <div id="spotlight-results"></div>
                    <input type="text" id="spotlight-input" placeholder="Type here to search...">
                </div>
            </div>
        </div>
    </div>
    <div class="start-menu" id="start-menu">
        <div class="colored glass window">
            <div class="title-bar">
                <div class="custom window-body">
                    <div class="pet">
                        <img src="images/icons/pcIcon.png" alt="pet">
                        <div role="tooltip">
                            <p>Welcome to the site.</p>
                        </div>
                    </div>
                </div>
                <div class="custom menu-sidebar">
                    <div class="top">
                        <button>
                            <a href="mailto:desk-feedback@glitchy.website?subject=Bug%20Report">Report a Bug </a>
                        </button>
                        <button>
                            <a href="mailto:desk-feedback@glitchy.website?subject=Feature%20Request">Request a Feature </a>
                        </button>
                    </div>
                    <div class="bottom">
                        <button id="shutdown">Shut down</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="colored glass taskbar-container window" style="visibility: hidden;">
        <div class="title-bar" style="padding: 0;">
            <div class="start-button">
                <img id="start-button" src="images/icons/startregular.png" alt="start">
            </div>
            <div id="taskbar" class="taskbar-btns">
                <div class="taskbar-btn active" style="width: auto; ">
                    <div class="taskbar-item icon-text" style="padding-left: 0.5rem; padding-right: 0.5rem;">
                        <img class="icon" src="images/icons/home.png" alt="Home" style="min-width: 2.2rem; min-height: 2.2rem;">
                        <p class="taskbar-label">Welcome Home!</p>
                    </div>
                </div>
                <div class="taskbar-btn" style="width: auto;">
                    <div class="taskbar-item icon-text" style="padding-left: 0.5rem; padding-right: 0.5rem;">
                        <img class="icon" src="images/icons/download.png" alt="Home" style="min-width: 2.2rem; min-height: 2.2rem;">
                        <p class="taskbar-label">Download</p>
                    </div>
                </div>
                <div class="taskbar-btn" style="width: auto;">
                    <div class="taskbar-item icon-text" style="padding-left: 0.5rem; padding-right: 0.5rem;">
                        <img class="icon" src="images/icons/book.png" alt="Home" style="min-width: 2.1rem; min-height: 2.1rem;">
                        <p class="taskbar-label">How to use / build?</p>
                    </div>
                </div>
                <div class="taskbar-btn" style="width: auto;">
                    <div class="taskbar-item icon-text" style="padding-left: 0.5rem; padding-right: 0.5rem;">
                        <img class="icon" src="images/icons/stats.png" alt="Home" style="min-width: 2.1rem; min-height: 2.1rem;">
                        <p class="taskbar-label">Stats & Progress</p>
                    </div>
                </div>
            </div>


            <div class="taskbar-icons">
                <img src="images/icons/tray/0.png" alt="icon1" class="small-icon sounds" id="volumeIcon">
                <img src="images/icons/music.webp" alt="icon4" class="small-icon music">
                <img src="images/icons/tray/notification.png" alt="icon1" class="small-icon notification">
            </div>

            <div class="clock" id="clock"style="margin-left: 0px;"></div>
            
        </div>
    </div>

    <section class="sticky-cols">
        <div class="sticky-cols-wrapper">
            <!-- Background video placed here so it sits behind the sticky cards
                 and only bleeds a bit into the intro/outro sections. -->
            <div class="bg-key-wrap" aria-hidden="true">
                <video class="bg-key" src="videos/theKey.mp4" muted autoplay loop playsinline preload="auto"></video>
            </div>
            <div class="col col-1">
                <div class="col-content">
                    <div class="col-content-wrapper liquid-glass">
                        <div class="liquid-glass--bend"></div>
                        <div class="liquid-glass--face"></div>
                        <div class="liquid-glass--edge"></div>
                        <h2>Closed-loop & Fully Automated</h2>
                        <p>Every resource in this base is produced, processed, and redistributed without manual input. Raw materials flow from farms to smelters to storage, feeding crafting, expansion, and trade in a seamless cycle. Nothing is decorative automation. Every system is integrated, scalable, and designed to run indefinitely without intervention.</p>
                    </div>
                </div>
            </div>
            <div class="col col-2">
                <div class="col-img col-img-1">
                    <div class="col-img-wrapper">
                        <img src="images/storage.png" alt="">
                    </div>
                </div>
                <div class="col-img col-img-2">
                    <div class="col-img-wrapper">
                        <img src="/images/hsrStation.png" alt="">
                    </div>
                </div>
            </div>
            <div class="col col-3">
                <div class="col-content-wrapper liquid-glass">
                    <div class="liquid-glass--bend"></div>
                    <div class="liquid-glass--face"></div>
                    <div class="liquid-glass--edge"></div>
                    <h2>Interconnected Transportation hub</h2>
                    <p>This base functions as a regional nexus where local metro lines, regional rail, and high-speed routes converge. It isn’t just a stop, it’s infrastructure. Movement between distant builds is intentional, efficient, and centralized, turning separate projects into a unified network.</p>
                </div>
                <div class="col-content-wrapper-2 liquid-glass">
                    <div class="liquid-glass--bend"></div>
                    <div class="liquid-glass--face"></div>
                    <div class="liquid-glass--edge"></div>
                    <h2>No visible farms. No exposed redstone. Pure Vibes</h2>
                    <p>Efficiency is hidden beneath architecture. Farms operate out of sight, redstone remains fully integrated into the structure, and automation never compromises atmosphere. Water features, greenery, and polished materials define the space. Performance and aesthetics coexisting without visible machinery.</p>
                </div>
            </div>
            <div class="col col-4">
                <div class="col-img">
                    <div class="col-img-wrapper">
                        <img src="images/autoSmelter.png">
                    </div>
                </div>                
            </div>
        </div>
    </section>

    <section class="outro">
        <h2>Thank you for visiting!</h2>
        <p>We hope you found what you were looking for.</p>

        <div class="social-links" style="background-color: 	#c3829e; color: #ffffff; position: absolute; bottom: 0; left: 0; right: 0; width: 100%; padding-top: 0.8rem;">
            <div id="OS logo" style="margin-left: 1.5rem; margin-top: 0.4rem;display: flex; flex-direction: column; align-items: center;">
                <p style="margin: 0 0 0.25rem 0; font-family: 'Segoe UI Light';">Compatible with</p>
                <img src="images/windows7.png" alt="Windows 7 Compatible" style="width: 9rem;">
            </div>
            <div id="credit" style="font-family: 'Frutiger'; margin-left: 1.8rem; margin-top: 0.5rem;display: flex; flex-direction: row; flex-wrap: wrap; max-width: calc(100% - 14rem);">
                <h4 style="width: 100%;">CommonWorld  F U T U R E  Project 000 ~ Codename `Sakura Archive`</h4>
                <p>dge5: Original Vision, Architect</p> 
                <p>happygrassblock: Architect, Contiuned Development, Website Design</p>
                <p>wslsp713: Site Discovery</p>
                <p>52013145129: Site Discovery</p>
                <p>m1chelin_man: Site Discovery</p>
                <p>mynameisnt_gary: Site Discovery, Resource Gathering</p>
                <p>honami.1: Site Discovery, Naming</p>
                <p>thedrexy: Resource Gathering</p>
                <p>infiniteenergyresource: Resource Gathering</p>
                <p>rainbay: Resource Gathering</p>

                <p style="margin-top: 0.8rem;">Special thanks to [PLACEHOLDER] for redstone builds used in the base design, [PLACEHOLDER] for the music used in the site.</p>
                <p style="width: 100%;"> and to Virtual Self- Key for the animated background</p>

                <p style="width: 100%; margin-top: 0.8rem;">Current OS: Horizon OS 1.0</p>
                <p style="font-size: 0.8rem;">オープン価格商品の問い合わせください。</p>
                <p style="text-align: right; width: 100%; margin-top: -0.8rem; margin-bottom: 0.8rem; font-family: 'Segoe UI Light';">さくらアーカイブ 2011 © All rights reserved.</p>
            </div>
        </div>

    </section>
</main>


<!--
Compatible with (Windows 7 image logo)

CommonWorld  F U T U R E  Project 000 ~ Codename `Sakura Archive`
dge5: Original Vision, Architect
happygrassblock: Architect, Contiuned Development
wslsp713, 52013145129, m1chelin_man: site discovery
mynameisnt_gary: site discovery, resource gathering
honami.1: site discovery, Naming
thedrexy, infiniteenergyresource, rainbay: resource gathering

Special thanks to [
PLACEHOLDER
] for redstone builds used in the base design, and to [
PLACEHOLDER
] for the music used in the site.

OS: Horizon OS 1.0
オープン価格商品の問い合わせください。

さくらアーカイブ 2011 © All rights reserved.
-->


    <!-- SVG Filter for Liquid Glass Effect -->
    <svg style="display: none" xmlns="http://www.w3.org/2000/svg">
        <filter id="glass-blur" x="0" y="0" width="100%" height="100%" filterUnits="objectBoundingBox">
            <feTurbulence type="fractalNoise" baseFrequency="0.003 0.007" numOctaves="1" result="turbulence" />
            <feDisplacementMap in="SourceGraphic" in2="turbulence" scale="200" xChannelSelector="R" yChannelSelector="G" />
        </filter>
    </svg>

    <script src="taskbar-backdrop-embed.js"></script>
    <script src="home.js"></script>
    
    <script>
        // Global audio state for music controls
        const musicBasePath = 'sounds/songs/';
        let bgMusic = null;
        let playlist = [];
        let currentIndex = 0;
        const volumeLevels = [0, 0.1, 0.2, 0.35, 0.5];
        let volumeLevelIndex = 3;
        const volumeStorageKey = 'musicVolumeLevelIndex';
        let introVisualizerContext = null;
        let introVisualizerAnalyser = null;
        let introVisualizerSource = null;
        let introVisualizerData = null;
        let introVisualizerConnectedAudio = null;

        const getSongLabel = (filename) => {
            if (!filename) return '';
            return filename.replace(/\.[^/.]+$/, '');
        };

        const initIntroVisualizer = () => {
            const canvas = document.getElementById('introVisualiserCanvas');
            const section = document.querySelector('.intro-visualiser');
            if (!canvas || !section) return;

            const ctx = canvas.getContext('2d');
            if (!ctx) return;

            const resizeCanvas = () => {
                const ratio = window.devicePixelRatio || 1;
                const width = Math.max(1, section.clientWidth);
                const height = Math.max(1, section.clientHeight);
                canvas.width = Math.floor(width * ratio);
                canvas.height = Math.floor(height * ratio);
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.scale(ratio, ratio);
            };

            const setupAnalyser = () => {
                if (!bgMusic || introVisualizerConnectedAudio === bgMusic) return;

                if (!introVisualizerContext) {
                    const AudioContextCtor = window.AudioContext || window.webkitAudioContext;
                    if (!AudioContextCtor) return;
                    introVisualizerContext = new AudioContextCtor();
                }

                introVisualizerAnalyser = introVisualizerContext.createAnalyser();
                introVisualizerAnalyser.fftSize = 1024;
                introVisualizerSource = introVisualizerContext.createMediaElementSource(bgMusic);
                introVisualizerSource.connect(introVisualizerAnalyser);
                introVisualizerAnalyser.connect(introVisualizerContext.destination);
                introVisualizerData = new Uint8Array(introVisualizerAnalyser.frequencyBinCount);
                introVisualizerConnectedAudio = bgMusic;
            };

            const draw = () => {
                requestAnimationFrame(draw);

                const width = section.clientWidth;
                const height = section.clientHeight;
                ctx.clearRect(0, 0, width, height);

                setupAnalyser();
                if (!introVisualizerAnalyser || !introVisualizerData) return;

                if (introVisualizerContext && introVisualizerContext.state === 'suspended') {
                    introVisualizerContext.resume().catch(() => {});
                }

                introVisualizerAnalyser.getByteFrequencyData(introVisualizerData);

                const bufferLength = introVisualizerData.length;
                const barGap = 3;
                const targetBarWidth = 4.5;
                const barCount = Math.max(1, Math.floor((width + barGap) / (targetBarWidth + barGap)) * 2);
                const barWidth = Math.max((width - (barCount - 1) * barGap) / barCount, 3);
                const sampleStep = bufferLength / barCount;
                let x = 0;

                for (let index = 0; index < barCount; index++) {
                    const sampleIndex = Math.min(bufferLength - 1, Math.floor(index * sampleStep));
                    const barHeight = (introVisualizerData[sampleIndex] / 255) * height;
                    ctx.fillStyle = 'rgba(248, 107, 199, 0.88)';
                    ctx.fillRect(x, height - barHeight, barWidth, barHeight);
                    x += barWidth + barGap;
                }
            };

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas, { passive: true });
            draw();
        };

        const updateSongLabels = () => {
            if (!playlist.length) return;
            const lastIndex = (currentIndex - 1 + playlist.length) % playlist.length;
            const nextIndex = (currentIndex + 1) % playlist.length;

            const lastEl = document.getElementById('lastSong');
            const currentEl = document.getElementById('currentSong');
            const nextEl = document.getElementById('nextSong');

            if (lastEl) lastEl.textContent = getSongLabel(playlist[lastIndex]);
            if (currentEl) currentEl.textContent = getSongLabel(playlist[currentIndex]);
            if (nextEl) nextEl.textContent = getSongLabel(playlist[nextIndex]);
        };

        const loadStoredVolume = () => {
            const stored = Number.parseInt(localStorage.getItem(volumeStorageKey), 10);
            if (!Number.isNaN(stored) && stored >= 0 && stored < volumeLevels.length) {
                volumeLevelIndex = stored;
            }
        };

        const persistVolume = () => {
            localStorage.setItem(volumeStorageKey, String(volumeLevelIndex));
        };

        const updateVolumeIcon = () => {
            const volumeIcon = document.getElementById('volumeIcon');
            if (volumeIcon) {
                volumeIcon.src = `images/icons/tray/${volumeLevelIndex}.png`;
            }
        };

        const applyVolume = () => {
            if (!bgMusic) return;
            bgMusic.volume = volumeLevels[volumeLevelIndex];
        };

        const ensureAudio = () => {
            if (bgMusic) return;
            bgMusic = new Audio();
            applyVolume();
            bgMusic.loop = false;
            bgMusic.addEventListener('ended', () => {
                playNext(true);
            });
        };

        const setPlayingState = (isPlaying) => {
            const playPauseImage = document.getElementById('audioPlayPauseImage');
            const cdImage = document.getElementById('cdImage');
            if (playPauseImage) {
                playPauseImage.src = isPlaying
                    ? 'images/icons/music/music_player_pause.png'
                    : 'images/icons/music/music_player_play.png';
            }
            if (cdImage) {
                if (isPlaying) {
                    cdImage.classList.add('playing');
                } else {
                    cdImage.classList.remove('playing');
                }
            }
        };

        const loadTrack = (index, autoplay) => {
            if (!playlist.length) return;
            ensureAudio();
            currentIndex = (index + playlist.length) % playlist.length;
            bgMusic.src = `${musicBasePath}${playlist[currentIndex]}`;
            updateSongLabels();
            if (autoplay) {
                bgMusic.play()
                    .then(() => setPlayingState(true))
                    .catch(err => console.log('Background music play failed:', err));
            } else {
                setPlayingState(false);
            }
        };

        const playNext = (autoplay = true) => {
            if (!playlist.length) return;
            loadTrack(currentIndex + 1, autoplay);
        };

        const playPrev = (autoplay = true) => {
            if (!playlist.length) return;
            loadTrack(currentIndex - 1, autoplay);
        };

        const loadPlaylist = async () => {
            try {
                const response = await fetch(`${musicBasePath}playlist.json`, { cache: 'no-store' });
                if (!response.ok) throw new Error(`Playlist load failed: ${response.status}`);
                const data = await response.json();
                if (!Array.isArray(data) || data.length === 0) {
                    throw new Error('Playlist is empty or invalid.');
                }
                playlist = data;
            } catch (err) {
                console.log('Playlist load failed:', err);
                playlist = [];
            }
        };

        // Scroll-lock helpers — lock page scroll while the welcome runs (prevents wheel/touch/keyboard)
        let _welcomeScrollLock = { locked: false, y: 0 };
        function _preventScrollDefault(e) { e.preventDefault(); }
        function _keydownScrollHandler(e) {
            const keys = [' ', 'PageUp', 'PageDown', 'End', 'Home', 'ArrowUp', 'ArrowDown'];
            if (keys.includes(e.key) || [32,33,34,35,36,38,40].includes(e.keyCode)) {
                e.preventDefault();
            }
        }
        function disableScroll() {
            if (_welcomeScrollLock.locked) return;
            _welcomeScrollLock.locked = true;
            _welcomeScrollLock.y = window.scrollY || document.documentElement.scrollTop || 0;
            document.documentElement.style.scrollBehavior = 'auto';
            document.body.style.position = 'fixed';
            document.body.style.top = `-${_welcomeScrollLock.y}px`;
            document.body.style.left = '0';
            document.body.style.width = '100%';
            document.body.style.overflow = 'hidden';
            document.documentElement.style.overflow = 'hidden';
            window.addEventListener('wheel', _preventScrollDefault, { passive: false });
            window.addEventListener('touchmove', _preventScrollDefault, { passive: false });
            document.addEventListener('keydown', _keydownScrollHandler, { passive: false });
        }
        function enableScroll() {
            if (!_welcomeScrollLock.locked) return;
            _welcomeScrollLock.locked = false;
            window.removeEventListener('wheel', _preventScrollDefault);
            window.removeEventListener('touchmove', _preventScrollDefault);
            document.removeEventListener('keydown', _keydownScrollHandler);
            document.body.style.position = '';
            document.body.style.top = '';
            document.body.style.left = '';
            document.body.style.width = '';
            document.body.style.overflow = '';
            document.documentElement.style.overflow = '';
            const y = _welcomeScrollLock.y || 0;
            window.scrollTo(0, y);
            document.documentElement.style.scrollBehavior = '';
        }

        // Welcome splash screen logic — controlled via pre-welcome page
        (function() {
            // ensure we only run welcome once
            window._welcomeStarted = window._welcomeStarted || false;

            const welcomeSplash = document.getElementById('welcome-splash');
            const welcomeProgressBar = document.getElementById('welcome-progressbar');
            const taskbar = document.querySelector('.taskbar-container');

            async function finishWelcome() {
                if (window._dismissGlassImage) window._dismissGlassImage();

                if (welcomeSplash) {
                    welcomeSplash.style.transition = 'opacity 0.5s ease-out';
                    welcomeSplash.style.opacity = '0';
                }
                if (welcomeProgressBar) {
                    welcomeProgressBar.style.transition = 'opacity 0.5s ease-out';
                    welcomeProgressBar.style.opacity = '0';
                }

                setTimeout(async function() {
                    if (welcomeSplash) welcomeSplash.style.display = 'none';
                    if (welcomeProgressBar) welcomeProgressBar.style.display = 'none';
                    enableScroll();
                    window.scrollTo(0, 0);
                    if (taskbar) taskbar.style.visibility = 'visible';

                    await loadPlaylist();
                    if (playlist.length) {
                        loadTrack(0, true);
                    }
                    updateVolumeIcon();
                    setTimeout(function() {
                        if (window.triggerMusicFlyoutIntro) window.triggerMusicFlyoutIntro();
                    }, 2000);
                }, 500);
            }

            function startWelcome() {
                // only allow once portal has been cleared
                if (!window._allowWelcome) {
                    console.log('startWelcome blocked until pre-welcome cleared');
                    return;
                }
                // If the pre-welcome page is still visible, defer starting the welcome
                const preEl = document.getElementById('pre-welcome-page');
                try {
                    if (preEl && getComputedStyle(preEl).display !== 'none') {
                        // schedule start when pre-welcome is hidden
                        if (!window._deferredWelcomeObserver) {
                            window._deferredWelcomeObserver = new MutationObserver((mutations, obs) => {
                                if (getComputedStyle(preEl).display === 'none') {
                                    obs.disconnect();
                                    window._deferredWelcomeObserver = null;
                                    // call start again now that pre-page is hidden
                                    startWelcome();
                                }
                            });
                            window._deferredWelcomeObserver.observe(preEl, { attributes: true, attributeFilter: ['style', 'class'] });
                        }
                        return;
                    }
                } catch (e) {
                    // defensive: if any error, continue to start
                }

                if (window._welcomeStarted) return;
                window._welcomeStarted = true;
                // fallback: stop portal audio if somehow still playing
                try {
                    if (window.portalAudio) {
                        window.portalAudio.pause();
                        window.portalAudio.src = '';
                        window.portalAudio = null;
                    }
                    if (window.portalAudioContext) {
                        window.portalAudioContext.close().catch(() => {});
                        window.portalAudioContext = null;
                    }
                } catch (e) { console.log('error stopping portal audio in startWelcome', e); }

                loadStoredVolume();

                const welcomeAudio = new Audio('sounds/welcome.mp3');
                welcomeAudio.volume = 0.3;

                // Prevent scrolling during welcome screen and hide scrollbar
                disableScroll();

                // Hide taskbar during welcome
                if (taskbar) taskbar.style.visibility = 'hidden';

                // Ensure splash elements are visible
                if (welcomeSplash) {
                    welcomeSplash.style.display = '';
                    welcomeSplash.style.opacity = '1';
                }
                if (welcomeProgressBar) {
                    welcomeProgressBar.style.display = '';
                    welcomeProgressBar.style.opacity = '1';
                }

                welcomeAudio.play().catch(err => console.log('Audio play failed:', err));
                welcomeAudio.addEventListener('ended', function() {
                    finishWelcome();
                });
            }

            // expose to global so merged pre-welcome can trigger welcome
            window.startWelcome = startWelcome;
            window.finishWelcome = finishWelcome;

                        // Insert original sound-warning overlay and gate the pre-welcome page behind it.
                        // Cookie check to gate intro video on first visit (copied from index.html)
                        const isFirstVisit = !document.cookie.includes("visited=true");
                        if (isFirstVisit) {
                                document.cookie = "visited=true; max-age=31536000; path=/"; // Expires in 1 year
                        }

                        // Original showSoundWarning implementation (copied verbatim from index.html)
                        function showSoundWarning(onDone, playIntro = false) {
                            const scopedHref = 'https://unpkg.com/7.css/dist/7.scoped.css';
                            const hasScoped = [...document.styleSheets].some(s => s.href && s.href.includes('7.css/dist/7.scoped.css'));

                            const createOverlay = () => {
                                const overlay = document.createElement('div');
                                overlay.style.position = 'fixed';
                                overlay.style.inset = '0';
                                overlay.style.zIndex = '2147483650';
                                overlay.style.display = 'flex';
                                overlay.style.alignItems = 'center';
                                overlay.style.justifyContent = 'center';
                                overlay.style.background = 'transparent';

                                const bgVideo = document.createElement('video');
                                bgVideo.src = 'videos/bg.mp4';
                                bgVideo.autoplay = true;
                                bgVideo.muted = true;
                                bgVideo.loop = true;
                                bgVideo.playsInline = true;
                                bgVideo.preload = 'auto';
                                bgVideo.style.position = 'absolute';
                                bgVideo.style.inset = '0';
                                bgVideo.style.width = '100%';
                                bgVideo.style.height = '100%';
                                bgVideo.style.objectFit = 'cover';
                                bgVideo.style.zIndex = '2147483650';
                                bgVideo.style.opacity = '1';
                                bgVideo.style.filter = 'brightness(.46)';

                                overlay.appendChild(bgVideo);
                                overlay.appendChild(wrapper);
                                bgVideo.play().catch(e => console.log('bg.mp4 autoplay blocked or failed:', e));
                                document.body.appendChild(overlay);

                                const ok = overlay.querySelector('#sound-ok');
                                if (ok) {
                                    ok.addEventListener('click', async () => {
                                        overlay.remove();

                                        if (!playIntro) {
                                            if (onDone) onDone();
                                            return;
                                        }

                                        const vOverlay = document.createElement('div');
                                        vOverlay.style.position = 'fixed';
                                        vOverlay.style.inset = '0';
                                        vOverlay.style.zIndex = '2147483660';
                                        vOverlay.style.display = 'flex';
                                        vOverlay.style.alignItems = 'center';
                                        vOverlay.style.justifyContent = 'center';
                                        vOverlay.style.background = '#000';

                                        const video = document.createElement('video');
                                        video.src = 'videos/weWereLiedTo.mp4';
                                        video.autoplay = false;
                                        video.playsInline = true;
                                        video.controls = false;
                                        video.preload = 'auto';
                                        video.volume = 0.25;
                                        video.style.maxWidth = '100%';
                                        video.style.maxHeight = '100%';
                                        video.style.width = '100%';
                                        video.style.height = '100%';

                                        vOverlay.appendChild(video);
                                        vOverlay.style.background = '#000';
                                        vOverlay.style.transition = '';
                                        document.body.appendChild(vOverlay);

                                        try {
                                            await video.play();
                                        } catch (err) {
                                            console.log('Intro video play failed or was blocked:', err);
                                            vOverlay.remove();
                                            if (onDone) onDone();
                                            return;
                                        }

                                        let fadeStarted = false;
                                        const fadeStart = 46.67;
                                        const fadeDuration = 2;
                                        const onTime = () => {
                                            const t = video.currentTime;
                                            if (!fadeStarted && t >= fadeStart) {
                                                fadeStarted = true;
                                                vOverlay.style.transition = `background ${fadeDuration}s linear`;
                                                vOverlay.style.background = '#fff';
                                            }
                                        };
                                        video.addEventListener('timeupdate', onTime);

                                        video.addEventListener('ended', () => {
                                            video.removeEventListener('timeupdate', onTime);
                                            vOverlay.remove();
                                            if (onDone) onDone();
                                        }, { once: true });
                                    });

                                    ok.addEventListener('keydown', (e) => {
                                        if (e.key === 'Enter' || e.key === ' ') {
                                            e.preventDefault();
                                            ok.click();
                                        }
                                    });
                                }
                            };

                            if (hasScoped) {
                                createOverlay();
                            } else {
                                const link = document.createElement('link');
                                link.rel = 'stylesheet';
                                link.href = scopedHref;
                                link.crossOrigin = 'anonymous';
                                let called = false;
                                link.onload = () => { if (!called) { called = true; createOverlay(); console.log('7.scoped.css loaded for sound dialog'); } };
                                link.onerror = () => { if (!called) { called = true; console.log('Failed to load 7.scoped.css for sound dialog — falling back'); createOverlay(); } };
                                setTimeout(() => { if (!called) { called = true; console.log('7.scoped.css load timeout — showing dialog'); createOverlay(); } }, 800);
                                document.head.appendChild(link);
                            }
                        }

                        // On load, show the sound-warning first and then the pre-welcome page
                        window.addEventListener('load', function() {
                                const pre = document.getElementById('pre-welcome-page');
                                const showPre = () => {
                                        // Hide the actual welcome canvas/progress until user moves past pre-welcome
                                        if (welcomeSplash) {
                                                welcomeSplash.style.display = 'none';
                                                welcomeSplash.style.opacity = '1';
                                        }
                                        if (welcomeProgressBar) {
                                                welcomeProgressBar.style.display = 'none';
                                                welcomeProgressBar.style.opacity = '1';
                                        }
                                        if (pre) {
                                                pre.style.display = 'flex';
                                                if (window._animateToggleOnPreShow && window.showPortalToggleOnce) {
                                                    window.showPortalToggleOnce();
                                                    window._animateToggleOnPreShow = false;
                                                }
                                        }
                                };

                                // showSoundWarning will call showPre when user clicks 'Got it' (and playIntro if first visit)
                                try {
                                        showSoundWarning(showPre, isFirstVisit);
                                } catch (e) {
                                        // fallback: just show pre-welcome (no animation since user didn't click)
                                        showPre();
                                }
                        });
        })();

        // Play/Pause and skip button functionality
        document.addEventListener('DOMContentLoaded', function() {
            initIntroVisualizer();

            const playPauseButton = document.getElementById('audioPlayPause');
            const backButton = document.getElementById('audioBack');
            const forwardButton = document.getElementById('audioForward');
            const volumeIcon = document.getElementById('volumeIcon');

            if (playPauseButton) {
                playPauseButton.addEventListener('click', function() {
                    if (!bgMusic) return;

                    if (bgMusic.paused) {
                        bgMusic.play()
                            .then(() => setPlayingState(true))
                            .catch(err => console.log('Play failed:', err));
                    } else {
                        bgMusic.pause();
                        setPlayingState(false);
                    }
                });
            }

            if (backButton) {
                backButton.addEventListener('click', function() {
                    playPrev(true);
                });
            }

            if (forwardButton) {
                forwardButton.addEventListener('click', function() {
                    playNext(true);
                });
            }

            if (volumeIcon) {
                updateVolumeIcon();
                volumeIcon.addEventListener('click', function() {
                    volumeLevelIndex = (volumeLevelIndex + 1) % volumeLevels.length;
                    applyVolume();
                    updateVolumeIcon();
                    persistVolume();
                });
            }
        });
    </script>
</body>
</html>